1. 受控组件
   把 input 和 state 的值关联起来了—>可以控制 input 里面的值
```js
// 受控组件
return (
    <div>
        <p>{this.state.name}</p>
        <label htmlFor="inputName">姓名：</label> {/* 用 htmlFor 代替 for */}
        <input id="inputName" value={this.state.name} onChange={this.onInputChange} />
    </div>
);

onInputChange = e => {
    this.setState({
        name: e.target.value,
    });
};
```
(vue 中使用 v-model 双向数据绑定，里面改相应的数据就改了；react 联动的效果需要自己写)
2. 非受控组件
input 输入的值不受 state 控制，输入与本身 state 没有关系（只是用 state 赋了初始值，没有写回调函数一点点存）
ref 
* 1)创建 ref【react推荐使用React.createRef()的api创建】
```js
constructor(props) {
    super(props)
    this.state = {
      name: '123',
      flag: true,
    }
    this.nameInputRef = React.createRef() // 创建 ref
    //React.createRef()调用后返回一个容器，该容器可以存储被ref所标示的节点
    this.fileInputRef = React.createRef()
}
```
* 2)dom
```js
render() {
  // input defaultValue
  return <div>
      {/* 使用 defaultValue 而不是 value ，使用 ref */}
      <input defaultValue={this.state.name} ref={this.nameInputRef}/>
      {/* state 并不会随着改变 */}
      <span>state.name: {this.state.name}</span>
      <br/>
      <button onClick={this.alertName}>alert name</button>
      </div>
}
// file
  return <div>
            <input type="file" ref={this.fileInputRef}/>
            <button onClick={this.alertFile}>alert file</button>
        </div>
```
**文件的时候必须得用 DOM 获得；某些富文本编辑器，需要传入 DOM 元素**
state 没有跟着变，不能再去 state 中取值，所以从 dom 中取 
其他ref用法：   
1)字符串ref="test"  this.refs.test  不推荐   
2)回调函数（内联：更新过程会执行两次，第一次会创建一个新的实例清空旧的ref）ref={(c)=>{this.input2 = c}}    
3)class绑定函数的形式不会调用两次  ref={this.saveInput}   
* 3)事件
```js
alertName = () => {
    const elem = this.nameInputRef.current // 通过 ref 获取 DOM 节点
    alert(elem.value) // 不是 this.state.name
}
alertFile = () => {
    const elem = this.fileInputRef.current // 通过 ref 获取 DOM 节点
    alert(elem.files[0].name)
}
```
使用的属性变更为 defaultValue defaultChecked
手动操作 dom 元素
受控组件 vs 非受控组件

-   优先使用受控组件，符合 React 设计原则【数据驱动视图】
-   必须操作 dom 时，再使用非受控组件

3. 表单使用
   <textarea/>中间不能写东西</textarea> 需要在标签里面写 value

-   input textarea select 都用 value
-   checkbox radio 用 checked

4. props
-   props 传递数据
-   props 传递函数 (vue：事件$emit)
-   props 类型检查、设置默认值
```js
import ProTypes from ‘prop-types'
List.propTypes = {  
    //propTypes是表示要定义规则，PropTypes是react封装的类
    list:PropTypes.arrayOf(PropTypes.object).isRequired     //必须有且必须为数组
}
```
**状态（数据）提升：会把数据提升到最高级的组件（父组件）**   
es6要求子类的构造函数必须执行一次super函数，因为子类的this要继承父类，super代表了父类的构造函数，返回的是子类的实例this指向子类，子类再在父类的this基础上加工   
super当作对象使用，指向父类的原型对象super.c()相当于A.prototype.c()       
super(props)构造器是否接收props是否传递给super，取决于是否希望在构造器中用this访问props   
