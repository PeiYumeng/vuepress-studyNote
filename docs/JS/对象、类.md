## 对象

#### 理解对象

对象是Object的实例，可以new一个也可以使用对象字面量构建自定义对象

属性分为：数据属性、访问器属性(内部特性会用[[]]包括起来)

1. 数据属性，包含保存数值的位置。
   - [[Configurable]]表示属性是否可删除并重新定义，是否可修改，是否可改为访问器属性
   - [[Enumerable]]表示属性是否可以通过for-in循环返回
   - [[Writable]]是否可修改
   - [[Value]]值
2. 访问器属性，不包含数据值包含getter\setter
   - [[Configurable]]表示是否可删除、重新定义、修改、是否可改为数据属性
   - [[Enumerable]]表示是否可循环
   - [[Get]]获取函数
   - [[Set]]设置函数
3. 相关API

- Object.defineProperty，可以修改属性的默认特性，参数：对象，属性名，描述符对象

```js
Object.defineProperty(book,'year',{
  get(){
    return this.year_
  }
  set(newValue){
  	if(newVlua > 2017){
      this.year_ = newValue
      this.edition += newValue - 2017		//访问器属性经典场景，即设置一个属性值会导致一些其他的变化发生  
    }
	}
})
```

- Object.defineProperties
- Object.getOwnPropertyDescriptor(book)  返回一个新对象中包含该对象所有自有属性
- Object.assign(目标对象，多个源对象)

源对象的所有本地属性复制到目标对象，源对象的属性得到了增强，但对每个源对象都是浅复制，相同属性覆盖

不能在两个对象间转移获取函数和设置函数

⚠️该方法不能回滚，如果执行到一半错误，之前已完成的修改会继续存在

- Object.is可以正确判断NaN

4. 语法

简写属性名：如果同名，自动解释为同名的属性键

动态属性复制：[nameKey]中括号包围的对象属性键表示表达式，而不是字符串（如果表达式错误也不会回滚之前的计算属性）

解构赋值：

同时定义默认值：let {name=personName}

起别名：{name:a}

嵌套：外层没有定义的情况下不能嵌套结构let {job:{title}}

部分解构：开始赋值成功后面报错，则整个解构赋值会完成一部分

#### 创建对象

单纯的new Object会编写很多重复的代码

1. 工厂模式

用于抽象创建特定对象的过程。（不再自己一个个创建对象，而是通过函数创建对象）

```js
function createPerson(name){
  let obj = new Obeject()
  obj.name = name
  return obj
}
```

🔔关键点：在函数内部创建一个对象，最后再返回该对象

🙅‍♀️缺点：没有解决对象标识问题（即新创建的对象是什么类型的，instanceof无法识别）

2. 构造函数模式

构造函数，是特殊的函数，用于创建特定类型对象，以函数的形式为自己的对象类型定义属性和方法

🆚与工厂模式相比：1⃣️没有显示的创建对象、2⃣️属性与方法直接赋值给this、3⃣️没有return

🆚与普通函数相比：调用方式不同（如果不用new将会绑在window上，其他则绑定在this指向哪个对象上）

构造函数后面的括号可加可不加，如果没有传参可以不写

```js
function Person(name){
  this.name = name
  this.sayName = fucntion(){
    console.log(this.name)
  }
}
let person1 = new Person('lala')
```

- 使用new操作符，会执行如下操作：
  - 在内存中创建一个新对象
  - 这个新对象的]\__proto__指向构造函数的prototype
  - 构造函数内部的this被复制为实例化的新对象
  - 执行构造函数内部代码
  - 返回对象

🔔关键点：使用构造函数，this赋值

✅好处：实例可以被标识为特定类型

🙅‍♀️缺点：构造函数定义的方法会在每个实例上都创建一遍，每个实例内都不是同一个function实例

因为方法都是做的一样的事情，this对象可以将函数与对象的绑定推迟在运行时==>可以把函数定义转移到构造函数外部

```js
function Person(name){
  this.sayName = sayName  //包含的只是一个指向外部函数的指针，所以实例共享了函数
}
function sayName(){
  console.log(this.name)
}
```

🙅‍♀️缺点：如果需要多个方法，就需要在全局作用域定义多个函数，代码不能很好的聚集在一起，全局作用于搞乱

3. 原型模式

原型：每个函数都有prototype属性，这个属性是一个对象，对象包含特定类型的实例共享的属性和方法

使用原型对象的好处是，在它上面定义的属性和方法都可以被对象实例共享

```js
function Person(){}
Person.prototype.name = 'Meng'
Person.prototype.sayName = function(){...}
let person1 = new person()
```

🆚与构造函数不同，使用这种原型模式定义的属性和方法是由所有实例共享的

🙅‍♀️缺点：任何时候对原型对象的修改都会在实例中反应出来，所有属性共享，引用值属性没有自己的属性副本

​				（原型上的引用值属性会一起都变，普通值类型不会相互影响）

​				弱化了向构造函数传递初始化参数的能力

- 原型：创建函数就会有prototype，所有原型对象自动获得constructor属性，指回构造函数

  Person.prototype.constructor == Person

- 实例\__proto__赋值为构造函数的原型对象
- 实例与构造函数无直接关系
- 沿着原型链寻找属性和方法，实例的同名属性可以遮蔽原有的

API

- Object.getPrototypeOf可以返回参数的\__proto__
- Object.setPrototypeOf可以重写实例私有属性，严重影响代码性能
- Object.create创建新对象，同时可以指定原型
- hasOwnPrototype可以判断在实例上还是在原型上
- in操作符，只要有该属性则为true（可以单独使用，也可以for in）
- Object.keys返回所有可枚举属性名称的字符串数组
- Object.values返回内容数组
- Object.entries返回键值对数组

⚠️如果构造函数的prototype被重写（比如用声明式再赋值）,则constructor属性不指回，可以在prototype内专门绑定

#### 继承

1. 原型链继承

通过原型继承多个引用类型的属性和方法

```js
function Father(){
  this.name = 'lalal'
}
Father.prototype.sayName = function(){...}
function Child(){
  this.age = 18
}
Child.prototype = new Father() //重点！这个赋值重写了最初的原型
let instance = new Child()
```

🔔关键点：子类没有使用默认原型，替换为新的对象，这个对象为父类的实例。Child.prototype == Father.prototype

🙅‍♀️缺点：原型中包含的引用值会在所有实例之间共享（所以通常定义在构造函数中）

​				子类在实例化的时候不能给父类传参

2. 盗用构造函数/对象伪装/经典继承

在子类的构造函数中调用父类构造函数，解决引用值问题

```js
function Father(){
  this.colors = ['red','blue']
}
function Child(){
  Father.call(this)
}
let instance = new Child()
```

相当于实例化的时候执行父类构造函数，则每个实例都有自己的属性

🔔关键点：在子类中call父类构造函数

✅好处：实例之间的引用类型不相互影响、子类构造函数中可以向父类传参

🙅‍♀️缺点：必须在构造函数中定义方法，函数不能重用；子类不能访问父类原型上定义的方法(构造函数中的可以，prototype写的不可以)

3. 组合继承

综合原型链+盗用构造函数，使用原型链继承属性和方法，盗用构造函数继承实例属性

（prortotype指向后原型链上的方法都可以访问到，实例化的时候盗用父类构造函数可以自身维护引用类型的属性）

```js
function Father(name){
	this.name = name
	this.colors = ['red','blue']
}
Father.prototype.say = function(){console.log('123')}
function Child(name,age){
  Father.call(this,name)
  this.age = age
}
Child.prototype = new Father()
```

🔔关键点：既在子类构造函数中call，又指向new的父类

✅好处：引用类型不会相互影响、可以用instanceof识别、可以向父类构造函数传参、可以继承父类原型上的方法

🙅‍♀️缺点：效率问题，父类构造函数调用两次

4. 原型式继承

即使不定义类型也可以通过原型实现信息共享==>适用于本来有一个对象，在这个基础上修改

```js
function object(o){
  function F(){}  //创建一个临时构造函数
  F.prototype = o	//在原来对象的基础上，本质是对传入对象进行一次浅复制
  return new F()
}
```

5. 寄生式继承

创建一个实现继承的函数，增强对象再返回这个对象

```js
function create(o){
  let clone = object(o)  //通过调用函数创建新对象（也可以使用别的函数创建）
  clone.say = function(){...}
  return clone
}
```

寄生式给对象添加函数也会导致难以服用

6. 寄生式组合继承

不通过调用父类构造函数给子类原型赋值，而是获得父类原型的副本。通过盗用构造函数继承属性，混合式原型链继承方法

```js
function inheritPrototype(child,fater){
  let prototype = objet(fater.prototype)
  prototype.constructor = child
  child.prototype = prototype
}
//构造Father同上
function Child(name,age){
  Father.call(this,name)
  this.age = age
}
inheritPrototype(Child,Fater)
```

只调用了一次父类的构造函数，避免了原型链上不必要的属性。

