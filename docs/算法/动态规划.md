#### 鸡蛋掉落
题目描述：k个鸡蛋N层楼，得出**m扔多少次**能求出鸡蛋最高在哪层楼不碎f     
情况分析：
1. 如果只有1一个鸡蛋，就从最底层一层层向上检查楼层，线性增加次数   
	【最差情况：从第一层检查到最高的楼层，操作次数为N次】   
2. 如果有无数个鸡蛋，即不在乎鸡蛋碎不碎，使用二分查找最快知道哪层碎了   
	【最差情况：二分查找被分割的次数最多的情况】   
3. 其他情况，就需要考虑鸡蛋碎不碎的问题，如果鸡蛋碎了就要向下⬇️找楼层，如果鸡蛋不碎检查⬆️上面的楼层，如果最后只剩一个鸡蛋或一层楼则得出结果   
最少移动次数 == 最坏情况下的扔鸡蛋次数（选择楼层情况不同，但要确保必须能得出f）   
🐣【方法一：暴力枚举 dp+递归】🐣
状态转移方程：
1. 碎了：鸡蛋k-1，检查楼层[1…N] => [1…i-1]   
2. 没碎：鸡蛋不变，检查楼层[1…N] => [i+1…N]   
3. 返回结果：max(碎，没碎) + 1    
	max获取的是剩下还需要扔的次数（里面递归函数的传参变化，求的是剩下的），1是现在这层楼扔的，一共返回的是在k个鸡蛋N层楼的情况下，需要多少次
4. 最终：max(dp(K - 1, i - 1), dp(K, N - i)) + 1
**在for循环里面，选择从哪层楼开始扔**，得每层楼开始扔得到的最终次数，最后获取一个最合适的楼层的**最小值(即最合适的从哪层开始扔最好)**   
**在i层楼里面使用递归**，找到子问题需要多少次
🐣【方法二：动态规划（增加备忘录）】🐣
动态规划算法的时间复杂度是: ⼦问题个数 × 函数本⾝的复杂度   
memo备忘录即Map哈希表📕   
备忘录可以避免重复的计算，比如我在递归第五层扔的时候，需要获取第四层数据结果，而我在for循环里也需要这个结果   
每次for循环计算出结果后，存储进来，之后再和调用dp时传参比较可以直接返回结果   
===========以上两种方法在力扣中都会超时===========
```js
function superEggDrop(K, N) {
    let map = new Map()
    // 定义dp函数
    function dp(K, N) {
        if (N === 0) {
            return 0;
        }
        if (K === 1) {
            return N;
        }
        let result = Number.MAX_SAFE_INTEGER;
        // 消除重复计算
        const key = `${N}_${K}`
        if (map.get(key) !== undefined) {
            return map.get(key);
        }
        // 穷举所有选择,i可以取到N值
        for (let i = 1; i <= N; i++) {
            // 状态转移方程
            result = Math.min(result, Math.max(
                dp(K - 1, i - 1),
                dp(K, N - i)
            ) + 1); 
        }
        map.set(key,result)
        return result;
    }
    return dp(K, N);
}
```
🐣【方法三：优化动态规划】🐣 ‼️
dp(K, N) 用数组表的话就是dp[k][n] = m 
改为：dp[k][m] = n  ‼️把递归函数变成二位数组‼️
知道还剩的鸡蛋，确切的次数，就能知道我剩几层楼没检查。即，我有k个鸡蛋，我可以尝试扔m次，最多扔n层
状态转移⽅程： dp[k][m] = dp[k][m - 1] + dp[k - 1][m - 1] + 1
 dp[k][m - 1]  没碎，往上走，扔的次数少了一次（即现在扔的这次），获取楼层
 dp[k - 1][m - 1] + 1  碎，往上走，扔的次数少了一次（即现在扔的这次），获取楼层
最后再加上现在这层楼
```js
function superEggDrop(K, N) {
    // 二维数组 [k+1]行 [N+1]列，初始化为0
    const dp = Array.from(Array(K+1), () => Array(N+1).fill(0));
    let m = 0;
    while (dp[K][m] < N) {
        m++;
        for (let k = 1; k <= K; k++) {
            dp[k][m] = dp[k][m - 1] + dp[k - 1][m - 1] + 1;
        }
    }
    return m;
}
```
🐣【方法四：二分查找】🐣
dp(K - 1, i - 1) 和 dp(K, N - i) 这两个函数，前者随着 i 的增加应该也是单调递增的；⽽后者随着 i 的增加应该 是单调递减的。
这时候求⼆者的较⼤值，再求这些最⼤值之中的最⼩值，其实就是求这两条直线交点，也就是折线的最低点。   