<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Hello VuePress</title>
    <meta name="generator" content="VuePress 1.8.3">
    <link rel="icon" href="./logo.png">
    <meta name="description" content="Just playing around">
    
    <link rel="preload" href="/vuepress-studyNote/assets/css/0.styles.7b8a0fd9.css" as="style"><link rel="preload" href="/vuepress-studyNote/assets/js/app.9ead1db4.js" as="script"><link rel="preload" href="/vuepress-studyNote/assets/js/2.2dfa3d4b.js" as="script"><link rel="preload" href="/vuepress-studyNote/assets/js/19.092221a1.js" as="script"><link rel="prefetch" href="/vuepress-studyNote/assets/js/10.b239de44.js"><link rel="prefetch" href="/vuepress-studyNote/assets/js/11.cc439b6f.js"><link rel="prefetch" href="/vuepress-studyNote/assets/js/12.9e334fdc.js"><link rel="prefetch" href="/vuepress-studyNote/assets/js/13.26d1bc7f.js"><link rel="prefetch" href="/vuepress-studyNote/assets/js/14.774d501d.js"><link rel="prefetch" href="/vuepress-studyNote/assets/js/15.fb4ad68d.js"><link rel="prefetch" href="/vuepress-studyNote/assets/js/16.471c5367.js"><link rel="prefetch" href="/vuepress-studyNote/assets/js/17.bf402e45.js"><link rel="prefetch" href="/vuepress-studyNote/assets/js/18.55a67d76.js"><link rel="prefetch" href="/vuepress-studyNote/assets/js/20.e6e96898.js"><link rel="prefetch" href="/vuepress-studyNote/assets/js/21.1f24b43b.js"><link rel="prefetch" href="/vuepress-studyNote/assets/js/22.ded6e141.js"><link rel="prefetch" href="/vuepress-studyNote/assets/js/23.9224de5c.js"><link rel="prefetch" href="/vuepress-studyNote/assets/js/24.ea860ff2.js"><link rel="prefetch" href="/vuepress-studyNote/assets/js/25.9b8405f0.js"><link rel="prefetch" href="/vuepress-studyNote/assets/js/26.f0aa8f8b.js"><link rel="prefetch" href="/vuepress-studyNote/assets/js/27.146cc663.js"><link rel="prefetch" href="/vuepress-studyNote/assets/js/28.f23510c3.js"><link rel="prefetch" href="/vuepress-studyNote/assets/js/29.17b353ec.js"><link rel="prefetch" href="/vuepress-studyNote/assets/js/3.f696b95d.js"><link rel="prefetch" href="/vuepress-studyNote/assets/js/30.2cf92a8d.js"><link rel="prefetch" href="/vuepress-studyNote/assets/js/31.f73d5039.js"><link rel="prefetch" href="/vuepress-studyNote/assets/js/32.d95ed760.js"><link rel="prefetch" href="/vuepress-studyNote/assets/js/33.60401af8.js"><link rel="prefetch" href="/vuepress-studyNote/assets/js/34.ed3c0b3a.js"><link rel="prefetch" href="/vuepress-studyNote/assets/js/35.21a4a8c9.js"><link rel="prefetch" href="/vuepress-studyNote/assets/js/36.2f32abf5.js"><link rel="prefetch" href="/vuepress-studyNote/assets/js/37.6d1d6212.js"><link rel="prefetch" href="/vuepress-studyNote/assets/js/38.372ce221.js"><link rel="prefetch" href="/vuepress-studyNote/assets/js/39.ad171d94.js"><link rel="prefetch" href="/vuepress-studyNote/assets/js/4.92f5ae78.js"><link rel="prefetch" href="/vuepress-studyNote/assets/js/40.b1769f5e.js"><link rel="prefetch" href="/vuepress-studyNote/assets/js/41.b8e8682d.js"><link rel="prefetch" href="/vuepress-studyNote/assets/js/42.54333677.js"><link rel="prefetch" href="/vuepress-studyNote/assets/js/43.791cf649.js"><link rel="prefetch" href="/vuepress-studyNote/assets/js/44.331835b7.js"><link rel="prefetch" href="/vuepress-studyNote/assets/js/45.cc083bc2.js"><link rel="prefetch" href="/vuepress-studyNote/assets/js/5.cfb94d19.js"><link rel="prefetch" href="/vuepress-studyNote/assets/js/6.a2228d71.js"><link rel="prefetch" href="/vuepress-studyNote/assets/js/7.18dac5ca.js"><link rel="prefetch" href="/vuepress-studyNote/assets/js/8.60d4c74b.js"><link rel="prefetch" href="/vuepress-studyNote/assets/js/9.7ed72fa8.js">
    <link rel="stylesheet" href="/vuepress-studyNote/assets/css/0.styles.7b8a0fd9.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/vuepress-studyNote/" class="home-link router-link-active"><!----> <span class="site-name">Hello VuePress</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>JS</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vuepress-studyNote/JS/基础知识.html" class="active sidebar-link">基础</a></li><li><a href="/vuepress-studyNote/JS/常用方法.html" class="sidebar-link">常用方法</a></li><li><a href="/vuepress-studyNote/JS/JS-Web-API.html" class="sidebar-link">JS-Web</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>算法</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>React</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Vue</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>NodeJs</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><ol><li>值类型 &amp; 引用类型</li></ol> <ul><li>值类型内容存储在<strong>栈</strong>中；引用类型<strong>栈</strong>中存储地址、对象内容存在<strong>堆</strong>里</li> <li>值类型：string number boolean undefined symbol null、【undefined必须用let定义】</li> <li>引用类型：对象、数组、函数<br>
【备注】null是特殊的值类型，相当于空对象；函数是特殊的引用类型<br>
📌undefined类型<br>
表示声明了但未初始化，在比较undefined字面值时两者相等<br>
永远不必显示地声明变量值为undefined，undefined必须用let定义<br>
📌null类型<br>
表示一个空对象的指针，在将来要保存对象值的变量建议初始化null<br>
null与undefined表面上相等，即==相等（因为==操作符会为了比较转换为操作数）<br>
📌boolean类型<br>
因为js区分大小写，所以True False不是布尔值❌<br>
📌number类型<br>
不同的数值类型有不同的数值字面量格式：0开头八进制、0x十六进制等<br>
  ☞浮点值<br>
浮点值的存储内存空间是整数的两倍，如果.后面没有数字或者跟着0都会视为整数<br>
由于IEEE754这个规范采用双精度存储，占64bit，🔔有存储限制不能表示所有的数，0.1+0.2 != 0.3‼️<br>
  ☞科学计数法，e后面跟着10的幂数；无穷大与无穷小 Infinity -Infinity.  isFinite()确定是不是有限大<br>
  ☞NaN<br>
用于表示本来要返回数值的操作失败了，比如非法计算，而不是报错<br>
NaN != NaN ，任何包含NaN的操作最终都返回NaN<br>
isNaN会尝试把它转换为数值，如果不能转换返回true<br>
📌String类型<br>
模版字面量支持字符串插值，通过${ }实现，在插值表达式中可以调用函数和方法<br>
split方法可以把字符串分隔为数组（数组变回字符串使用join方法）
📌Symbol类型<br>
表示独一无二的值，最多的用法是用来定义对象的唯一属性名<div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> sy <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">&quot;key1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> syObject <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span>sy<span class="token punctuation">]</span><span class="token operator">:</span> <span class="token string">&quot;kk&quot;</span>     <span class="token comment">//Symbol 值作为属性名时，该属性是公有属性不是私有属性，可以在类的外部访问，但是for...in等无法返回</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div>如果要读取到一个对象的 Symbol 属性，可以通过 Object.getOwnPropertySymbols() 和 Reflect.ownKeys()</li></ul> <ol start="2"><li>var let const区别</li></ol> <ul><li>var：可根据位置定义局部变量、全局变量，如果省略var则可以创建一个全局变量<br> <strong>声明提升：会自动把变量声明提升到函数作用域的顶部 ❗</strong><br>
合并：反复声明同一个变量没问题，会自动将多余的声明在作用域顶部合并为一个声明<br>
For循环定义的<strong>迭代变量会渗透到循环体外部</strong>，迭代变量保存的是导致循环退出的值</li></ul> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> <span class="token constant">I</span> <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">5</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment">//都是5，所有的i都是同一个变量</span>
  <span class="token punctuation">}</span>
</code></pre></div><p>【可以通过let或立即执行函数实现效果】</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">'World'</span><span class="token punctuation">;</span>
<span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> name <span class="token operator">===</span> <span class="token string">'undefined'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">'Jack'</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Goodbay '</span> <span class="token operator">+</span> name<span class="token punctuation">)</span>   <span class="token comment">//输出！因为var name被提升了</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Hello '</span> <span class="token operator">+</span> name<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><ul><li>let： 块级作用域（es6新增）<br>
不会在作用域中被提升，声明前面被称为“暂时性死区”<br>
不允许在同一个块级作用域中出现冗余的重复声明<br>
不能依赖条件声明模式（即if什么再let，离开if找不到变量）<br> <strong>Js引擎在后台会为每个迭代循环声明一个新的迭代变量，循环内每个setTimeout引用的都是不同的变量实例，不会被覆盖</strong><br> <strong>let定义的块级作用域，绑定事件可以逐个绑定（全局触发时候才绑定，迭代变量都是最后一个值）</strong></li> <li>const: 块级作用域、不允许重复声明（es6新增）<br>
声明时必须同时初始化变量（赋值），不能修改否则报错<br>
const声明的限制只适用于它指向的变量的引用，如果是一个对象，修改对象内的属性不违反限制<br>
const不能用来声明迭代变量（迭代变量自增）<br>
可以用const声明一个不会被修改的for循环变量，对for of \for in有用【遍历对象属性、数组】<br>
使用const可以让静态代码分析工具提前发现不合法的赋值操作</li> <li>【自由变量】<br>
自由变量：一个变量在当前作用域没有定义，但是引用了，就层层往上找，没有报错undefined<br>
自由变量的查找，是在函数定义的地方❗，<strong>向上级作用域查找，不是在执行的地方</strong></li></ul> <ol start="3"><li>typeof运算符<br> <strong>识别所有值类型、识别函数、可以判断是否为引用类型</strong><br> <strong>string number boolean undefined symbol object function</strong><br>
【typeof null === 'object'】</li> <li>instanceof
<strong>instanceof是基于原型链实现的，顺着隐式原型往上找</strong><br>
可以判断引用类型，可以判断类属于哪个class或构造函数</li> <li>深拷贝
【手写深度比较】</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">deepClone</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> object <span class="token operator">!==</span> <span class="token string">'object'</span> <span class="token operator">||</span> obj <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> obj
  <span class="token punctuation">}</span>
  <span class="token keyword">let</span> result
  obj <span class="token keyword">instanceof</span> <span class="token class-name">Array</span> <span class="token operator">?</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">:</span> result <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> obj<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment">//for..in会返回原型链上的key</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment">//是自己的属性，保证key不是原型的属性</span>
      result<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">deepClone</span><span class="token punctuation">(</span>obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> result
<span class="token punctuation">}</span>
</code></pre></div><p>深拷贝方法</p> <ul><li>let obj2 = JSON.parse(JSON.stringify(obj)) //不可以拷贝 undefined function RegExp 等类型</li> <li>let obj2 = Obejct.assgin({},obj1) //只能拷贝一层，如果对象的属性是引用类型则还只是拷贝了引用</li></ul> <ol start="6"><li>类型转换
除了 == null 都用 === 【==null相当于 (===null || ===undefined)】
强制类型转换：parseInt parseFloat toString
隐式类型转换：if \ == \ +
赋初始值的时候可以let str = 'abc' || &quot;&quot;</li> <li>原型</li></ol> <ul><li>隐式原型__proto__</li> <li>显式原型prototype<br> <strong>每个实例对象都有隐式原型__proto__，每个class都有显式原型prototype（构造函数指向原型对象）</strong><br>
xialuo.<strong>proto</strong> === Student.prototype<br>
通过new实例化的对象，的隐式原型指向构造函数的显示原型<br>
寻找属性或者方法的时候，先在自身属性方法中寻找，没有再去隐式原型__proto__中寻找</li> <li>new关键字的过程<br>
(1)新建一个对象<br>
(2)新对象的proto指向构造函数的原型对象<br>
(3)构造函数的this指向新对象<br>
(4)执行构造函数<br>
(5)返回新对象<br> <img src="/vuepress-studyNote/assets/img/1.361787d0.png" alt="原型链示意"></li></ul> <ol start="8"><li>闭包：在外部访问函数里的变量</li></ol> <ul><li>函数作为返回值被返回</li> <li>函数作为参数被传递</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token number">100</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment">//内部函数作为返回值被传递</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> fn <span class="token operator">=</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token number">200</span>
<span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">//100</span>
<span class="token comment">/* =========================== */</span>
<span class="token keyword">function</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token number">200</span>
  <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">//内部函数是外部传来的参数</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token number">100</span>
<span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>  <span class="token comment">//！！！自由变量的寻找是在函数定义的地方</span>
<span class="token punctuation">}</span>
<span class="token function">print</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span>  <span class="token comment">//100</span>
</code></pre></div><p>应用：缓存数据 闭包可以隐藏数据，只提供API</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">createCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">//闭包中的数据隐藏，对外提供API</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">set</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">key<span class="token punctuation">,</span>value</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment">//必须用set改变值</span>
      data<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> val
    <span class="token punctuation">}</span>
    <span class="token function-variable function">get</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">key</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token keyword">return</span> data<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>🙅‍♀️闭包的缺点是一直占用内存，会导致内存泄露，可以再调用结束后重写闭包函数释放内存<br>
9. this
<strong>this的取值是在函数执行的时候决定的，不是定义的时候❗</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> zhangsan <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span><span class="token string">'lalala'</span>
  <span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token comment">//指向当前对象</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">waitAgain</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token function">funcion</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token comment">//window,因为触发函数的是setTimeout</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
     <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token comment">//当前对象，因为箭头函数的this永远取上级作用域的this</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>改变this指向:call直接执行改变、bind会返回新函数、apply接受参数为数组形式
【模拟bind函数】</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">bind1</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">const</span> args <span class="token operator">=</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>rguments<span class="token punctuation">)</span> <span class="token comment">//多个传参拆解为数组</span>
  <span class="token keyword">const</span> t <span class="token operator">=</span> args<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">const</span> self <span class="token operator">=</span> <span class="token keyword">this</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">self</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span>args<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><ol start="10"><li>对象
对象是Object的实例，可以new一个也可以使用对象字面量构建自定义对象。构造函数new的都是Object类型，无法是Function的实例
属性分为：数据属性、访问器属性(内部特性会用[[]]包括起来)
（1）数据属性，包含保存数值的位置。</li></ol> <ul><li>[[Configurable]]表示属性是否可删除并重新定义，是否可修改，是否可改为访问器属性</li> <li>[[Enumerable]]表示属性是否可以通过for-in循环返回</li> <li>[[Writable]]是否可修改</li> <li>[[Value]]值
（2）访问器属性，不包含数据值包含getter\setter</li> <li>[[Configurable]]表示是否可删除、重新定义、修改、是否可改为数据属性</li> <li>[[Enumerable]]表示是否可循环</li> <li>[[Get]]获取函数</li> <li>[[Set]]设置函数
（3）相关API</li> <li>Object.defineProperty，可以修改属性的默认特性，参数：对象，属性名，描述符对象</li></ul> <div class="language-js extra-class"><pre class="language-js"><code>Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>book<span class="token punctuation">,</span><span class="token string">'year'</span><span class="token punctuation">,</span><span class="token punctuation">{</span>
  <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>year_
  <span class="token punctuation">}</span>
  <span class="token function">set</span><span class="token punctuation">(</span>newValue<span class="token punctuation">)</span><span class="token punctuation">{</span>
  	<span class="token keyword">if</span><span class="token punctuation">(</span>newVlua <span class="token operator">&gt;</span> <span class="token number">2017</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>year_ <span class="token operator">=</span> newValue
      <span class="token keyword">this</span><span class="token punctuation">.</span>edition <span class="token operator">+=</span> newValue <span class="token operator">-</span> <span class="token number">2017</span>		<span class="token comment">//访问器属性经典场景，即设置一个属性值会导致一些其他的变化发生  </span>
    <span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><ul><li>Object.defineProperties</li> <li>Object.getOwnPropertyDescriptor(book)  返回一个新对象中包含该对象所有自有属性</li> <li>Object.assign(目标对象，多个源对象)：源对象的所有本地属性复制到目标对象，浅复制，不能在两个对象间转移获取函数和设置函数
🙅‍♀️该方法不能回滚，如果执行到一半错误，之前已完成的修改会继续存在</li> <li>Object.is可以正确判断NaN<br>
（4）语法<br>
简写属性名：如果同名，自动解释为同名的属性键（比如this.setState可以只写一个名去改变状态）<br>
动态属性复制：[nameKey]中括号包围的对象属性键表示表达式，而不是字符串（如果表达式错误也不会回滚之前的计算属性，这样可以动态的写一个函数设置多个不同属性）<br>
解构赋值：
<ul><li>同时定义默认值：let {name=personName}</li> <li>起别名：{name:a}</li> <li>嵌套：外层没有定义的情况下不能嵌套结构let {job:{title}}</li> <li>部分解构：开始赋值成功后面报错，则整个解构赋值会完成一部分</li></ul></li></ul> <ol start="11"><li>创建对象：工厂模式、构造函数模式、原型模式<br>
单纯的new Object会编写很多重复的代码<br>
（1）工厂模式<br>
用于抽象创建特定对象的过程（不再自己一个个创建对象，而是通过函数创建对象）</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">createPerson</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Obeject</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  obj<span class="token punctuation">.</span>name <span class="token operator">=</span> name
  <span class="token keyword">return</span> obj
<span class="token punctuation">}</span>
</code></pre></div><p>🔔关键点：在函数内部创建一个对象，最后再返回该对象<br>
🙅‍♀️缺点：没有解决对象标识问题（即新创建的对象是什么类型的，instanceof无法识别）<br>
（2）构造函数模式<br>
构造函数，是特殊的函数，用于创建特定类型对象，以函数的形式为自己的对象类型定义属性和方法<br>
🆚与工厂模式相比：1⃣️没有显示的创建对象、2⃣️属性与方法直接赋值给this、3⃣️没有return<br>
🆚与普通函数相比：调用方式不同（如果不用new将会绑在window上，其他则绑定在this指向哪个对象上）<br>
构造函数后面的括号可加可不加，如果没有传参可以不写</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
  <span class="token keyword">this</span><span class="token punctuation">.</span>sayName <span class="token operator">=</span> <span class="token function">fucntion</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'lala'</span><span class="token punctuation">)</span>
</code></pre></div><ul><li>使用new操作符，会执行如下操作：
<ul><li>在内存中创建一个新对象</li> <li>这个新对象的]__proto__指向构造函数的prototype</li> <li>构造函数内部的this被复制为实例化的新对象</li> <li>执行构造函数内部代码</li> <li>返回对象
🔔关键点：使用构造函数，this赋值
✅好处：实例可以被标识为特定类型
🙅‍♀️缺点：构造函数定义的方法会在每个实例上都创建一遍，每个实例内都不是同一个function实例
因为方法都是做的一样的事情，this对象可以将函数与对象的绑定推迟在运行时==&gt;可以把函数定义转移到构造函数外部</li></ul></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>sayName <span class="token operator">=</span> sayName  <span class="token comment">//包含的只是一个指向外部函数的指针，所以实例共享了函数</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>🙅‍♀️缺点：如果需要多个方法，就需要在全局作用域定义多个函数，代码不能很好的聚集在一起，全局作用于搞乱<br>
（3）原型模式<br>
原型：每个函数都有prototype属性，这个属性是一个对象，对象包含特定类型的实例共享的属性和方法<br>
使用原型对象的好处是，在它上面定义的属性和方法都可以被对象实例共享</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'Meng'</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span>
<span class="token keyword">let</span> person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">person</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>🆚与构造函数不同，使用这种原型模式定义的属性和方法是由所有实例共享的<br>
🙅‍♀️缺点：任何时候对原型对象的修改都会在实例中反应出来，所有属性共享，引用值属性没有自己的属性副本<br>
​				（原型上的引用值属性会一起都变，普通值类型不会相互影响）<br>
​				弱化了向构造函数传递初始化参数的能力</p> <ul><li>原型：创建函数就会有prototype，所有原型对象自动获得constructor属性，指回构造函数<br>
Person.prototype.constructor == Person</li> <li>实例__proto__赋值为构造函数的原型对象</li> <li>实例与构造函数无直接关系</li> <li>沿着原型链寻找属性和方法，实例的同名属性可以遮蔽原有的<br>
【API】</li> <li>Object.getPrototypeOf可以返回参数的_<em>proto</em>_</li> <li>Object.setPrototypeOf可以重写实例私有属性，严重影响代码性能</li> <li>Object.create创建新对象，同时可以指定原型</li> <li>hasOwnPrototype可以判断在实例上还是在原型上</li> <li>in操作符，只要有该属性则为true（可以单独使用，也可以for in）</li> <li>Object.keys返回🔔所有可枚举属性名称的字符串数组</li> <li>Object.values返回内容数组</li> <li>Object.entries返回键值对数组<br>
🔔如果构造函数的prototype被重写（比如用声明式再赋值）,则constructor属性不指回，可以在prototype内专门绑定</li></ul> <ol start="12"><li>继承<br>
（1）原型链继承<br>
通过原型继承多个引用类型的属性和方法</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Father</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'lalal'</span>
<span class="token punctuation">}</span>
<span class="token class-name">Father</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">18</span>
<span class="token punctuation">}</span>
<span class="token class-name">Child</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Father</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//重点！这个赋值重写了最初的原型</span>
<span class="token keyword">let</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>🔔关键点：子类没有使用默认原型，替换为新的对象，这个对象为父类的实例。Child.prototype == Father.prototype<br>
🙅‍♀️缺点：原型中包含的引用值会在所有实例之间共享（所以通常定义在构造函数中）<br>
​				子类在实例化的时候不能给父类传参<br>
（2）盗用构造函数/对象伪装/经典继承<br>
在子类的构造函数中调用父类构造函数，解决引用值问题</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Father</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'red'</span><span class="token punctuation">,</span><span class="token string">'blue'</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token function">Father</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>相当于实例化的时候执行父类构造函数，则每个实例都有自己的属性<br>
🔔关键点：在子类中call父类构造函数<br>
✅好处：实例之间的引用类型不相互影响、子类构造函数中可以向父类传参<br>
🙅‍♀️缺点：必须在构造函数中定义方法，函数不能重用；子类不能访问父类原型上定义的方法(构造函数中的可以，prototype写的不可以)<br>
（3）组合继承<br>
综合原型链+盗用构造函数，使用原型链继承属性和方法，盗用构造函数继承实例属性<br>
（prortotype指向后原型链上的方法都可以访问到，实例化的时候盗用父类构造函数可以自身维护引用类型的属性）</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Father</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
	<span class="token keyword">this</span><span class="token punctuation">.</span>colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'red'</span><span class="token punctuation">,</span><span class="token string">'blue'</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
<span class="token class-name">Father</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">say</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'123'</span><span class="token punctuation">)</span><span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span>age</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token function">Father</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>name<span class="token punctuation">)</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age
<span class="token punctuation">}</span>
<span class="token class-name">Child</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Father</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>🔔关键点：既在子类构造函数中call，又指向new的父类<br>
✅好处：引用类型不会相互影响、可以用instanceof识别、可以向父类构造函数传参、可以继承父类原型上的方法<br>
🙅‍♀️缺点：效率问题，父类构造函数调用两次<br>
（4）原型式继承<br>
即使不定义类型也可以通过原型实现信息共享==&gt;适用于本来有一个对象，在这个基础上修改</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">object</span><span class="token punctuation">(</span><span class="token parameter">o</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">function</span> <span class="token constant">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token comment">//创建一个临时构造函数</span>
  <span class="token class-name">F</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> o	<span class="token comment">//在原来对象的基础上，本质是对传入对象进行一次浅复制</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>（5）寄生式继承<br>
创建一个实现继承的函数，增强对象再返回这个对象</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token parameter">o</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">let</span> clone <span class="token operator">=</span> <span class="token function">object</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span>  <span class="token comment">//通过调用函数创建新对象（也可以使用别的函数创建）</span>
  clone<span class="token punctuation">.</span><span class="token function-variable function">say</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span>
  <span class="token keyword">return</span> clone
<span class="token punctuation">}</span>
</code></pre></div><p>寄生式给对象添加函数也会导致难以服用<br>
（6）寄生式组合继承<br>
不通过调用父类构造函数给子类原型赋值，而是获得父类原型的副本。通过盗用构造函数继承属性，混合式原型链继承方法</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">inheritPrototype</span><span class="token punctuation">(</span><span class="token parameter">child<span class="token punctuation">,</span>fater</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">let</span> prototype <span class="token operator">=</span> <span class="token function">objet</span><span class="token punctuation">(</span>fater<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span>
  prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> child
  child<span class="token punctuation">.</span>prototype <span class="token operator">=</span> prototype
<span class="token punctuation">}</span>
<span class="token comment">//构造Father同上</span>
<span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span>age</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token function">Father</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>name<span class="token punctuation">)</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age
<span class="token punctuation">}</span>
<span class="token function">inheritPrototype</span><span class="token punctuation">(</span>Child<span class="token punctuation">,</span>Fater<span class="token punctuation">)</span>
</code></pre></div><p>只调用了一次父类的构造函数，避免了原型链上不必要的属性。<br>
13. event loop事件循环/事件轮询<br>
主要模块：Browser console、Call Stack、Web APIs、Callback Queue<br>
①	一行行执行同步代码，推入到call stack调用栈中，执行之后清除<br>
②	遇到异步代码先记录下来等待时机，即放到WebApi然后从调用栈中清除<br>
③	时机到了移动到Callback Queue回调队列中<br>
④	当调用栈为空时，即同步代码执行结束后，Event loop开始执行<br>
⑤	轮询查找Callback Queue，若有则推入到调用栈中<br>
⑥	继续轮询<br>
异步基于event loop，DOM事件也使用回调基于event loop<br>
①	每次Call Stack清空（即每次轮询结束），即同步任务执行完成<br>
②	都是DOM重新渲染的机会，DOM结构如有变化则会重新渲染<br>
③	然后再去触发下一次Event Loop<br>
14. promise
背景：</p> <blockquote><p>JS是单线程语言，JS和DOM渲染共用一个线程，因为JS可修改DOM结构<br>
浏览器和nodejs已支持js启动进程，如web Worker<br>
需要异步解决遇到等待不能卡住的问题（网络请求、定时任务），基于回调callback形式会造成回调函数</p></blockquote> <p>三种状态：pending fufilled rejectes<br>
pending不可逆变为resolved或rejected，pending状态不会触发then\catch<br>
resolved状态会触发then,rejected会触发catch<br> <strong>then和catch正常返回resolved，里面有报错返回rejeted</strong>
【promise实现红绿灯】</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">index</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment">//不断循环</span>
        <span class="token keyword">await</span> <span class="token function">lightChange</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">,</span><span class="token string">'red'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">await</span> <span class="token function">lightChange</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">,</span><span class="token string">'yellow'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">await</span> <span class="token function">lightChange</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">,</span><span class="token string">'green'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">lightChange</span><span class="token punctuation">(</span><span class="token parameter">duration<span class="token punctuation">,</span>color</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span>reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      light<span class="token punctuation">.</span>style<span class="token punctuation">.</span>backgroundColor <span class="token operator">=</span> color<span class="token punctuation">;</span>
      <span class="token function">setTimeout</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span>duration<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//n秒后resolve结束</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><ol start="15"><li>async/await<br>
是同步语法编写异步代码，彻底消灭回调函数<br>
await后面的内容都是回调里面的内容，即异步，相当于event loop放到等待区域</li> <li>微任务&amp;宏任务
宏任务：setTimeout setInterval Ajax Dom事件,在DOM渲染后触发<br>
微任务：Promise async/await 【早执行】在DOM渲染前触发<br>
微任务是ES6语法规定的，宏任务是由浏览器规定的</li></ol></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/vuepress-studyNote/JS/常用方法.html">
        常用方法
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/vuepress-studyNote/assets/js/app.9ead1db4.js" defer></script><script src="/vuepress-studyNote/assets/js/2.2dfa3d4b.js" defer></script><script src="/vuepress-studyNote/assets/js/19.092221a1.js" defer></script>
  </body>
</html>
